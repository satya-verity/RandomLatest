using Antlr4.Runtime;
using OCLCMacroLanguage.Frontend.Parser;
using OCLCMacroLanguage.Frontend.SemanticAnalyzer;
using OCLCMacroLanguage.Frontend.SemanticAnalyzer.OMLSymbolTable;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MacroRunner.Frontend.SemanticAnalyzer
{
    public class SemanticAnalyzer
    {
        private readonly OMLErrorListener errorsListener;
        private readonly AstBuildingVisitor astBuilder;

        public SemanticAnalyzer(OMLErrorListener errorsListener, AstBuildingVisitor astBuilder)
        {
            this.errorsListener = errorsListener ?? throw new ArgumentNullException(nameof(errorsListener));
            this.astBuilder = astBuilder ?? throw new ArgumentNullException(nameof(astBuilder));
        }

        public SemanticContext BuildContext(string source)
        {
            OMLLexer lexer = new OMLLexer(new AntlrInputStream(source));
            CommonTokenStream tokens = new CommonTokenStream(lexer);
            OMLParser parser = new OMLParser(tokens);

            parser.RemoveErrorListeners();
            parser.AddErrorListener(errorsListener);

            // Invoke the start rule of the parser to build the parse tree
            var parseTree = parser.startRule();

            IAstNode ast = astBuilder.VisitStartRule(parseTree);

            return new SemanticContext(ast, astBuilder.Scopes);
        }

        public void ReportError(ErrorContext errorContext)
        {
            errorsListener.ReportError(errorContext);
        }
    }
}


using OCLCMacroLanguage.Frontend.SemanticAnalyzer;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MacroRunner.Frontend.SemanticAnalyzer
{
    public class SemanticContext
    {     
        public IAstNode Ast { get; set; }
        public ISymbolTableScopeResolver Scopes { get; set; }

        public SemanticContext(IAstNode ast, ISymbolTableScopeResolver scopes)
        {
            Ast = ast;
            Scopes = scopes;
        }
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MacroRunner.Frontend.SemanticAnalyzer
{
    public class ErrorContext
    {      
        public int Line { get; set; }
        public int Start { get; set; }
        public int End { get; set; }
        public string Message { get; set; }
        public SeverityLevel Severity { get; set; }

        public ErrorContext(int line, int start, int end, string message, SeverityLevel severity)
        {
            Line = line;
            Start = start;
            End = end;
            Message = message;
            Severity = severity;
        }

    }
}
using Antlr4.Runtime.Misc;
using OCLCMacroLanguage.Frontend.Parser;
using OCLCMacroLanguage.Frontend.SemanticAnalyzer;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MacroRunner.Frontend.SemanticAnalyzer
{
    public class AstBuildingVisitor: OMLParserBaseVisitor<IAstNode>
    {
        private readonly AstFactory astFactory;
        private readonly TypeResolver typeResolver;
        public ISymbolTableScopeResolver Scopes { get; }


        public AstBuildingVisitor(AstFactory astFactory, ISymbolTableScopeResolver scopeResolver, TypeResolver typeResolver)
        {
            this.astFactory = astFactory ?? throw new ArgumentNullException(nameof(astFactory));
            this.Scopes = scopeResolver ?? throw new ArgumentNullException(nameof(scopeResolver));
            this.typeResolver = typeResolver ?? throw new ArgumentNullException(nameof(typeResolver));
        }

        public override IAstNode VisitStartRule([NotNull] OMLParser.StartRuleContext context)
        {
            return base.VisitStartRule(context);
        }
    }
}
using OCLCMacroLanguage.Frontend.SemanticAnalyzer.OMLSymbolTable;

namespace OCLCMacroLanguage.Frontend.SemanticAnalyzer
{
    public interface ISymbolTableScopeResolver
    {
        string ModuleId { get; }
        void SetModuleName(string moduleName);
        void UseMemoryContext(MemoryScope memoryScope);
        MemoryScope GetActiveMemoryScope();
        ISymbolTable CreateFreshProcedureContext();
        ISymbolTable CreateCustomTypeContext();
        ISymbolTableEntry EnterActive(string name);
        ISymbolTableEntry Lookup(string name);
        ISymbolTableEntry LookupInScope(MemoryScope scope, string name);
        ISymbolTable GetMemoryContext(MemoryScope memoryScope);
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MacroRunner.Frontend.SemanticAnalyzer
{    public enum SeverityLevel
    {
        ERROR,
        WARNING
    }
}
using Antlr4.Runtime;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MacroRunner.Frontend.SemanticAnalyzer
{
    public class OMLErrorListener : BaseErrorListener
    {
        private readonly ErrorPostProcessor errorPostProcessor;

        public OMLErrorListener(ErrorPostProcessor errorPostProcessor)
        {
            this.errorPostProcessor = errorPostProcessor ?? throw new ArgumentNullException(nameof(errorPostProcessor));
        }

        public override void SyntaxError(TextWriter output, IRecognizer recognizer, IToken offendingSymbol, int line, int charPositionInLine, string msg, RecognitionException e)
        {
            string userFriendlyError = errorPostProcessor.TransformError(msg);
            ReportError(new ErrorContext(line, charPositionInLine + 1, charPositionInLine + offendingSymbol.StopIndex - offendingSymbol.StartIndex + 2, userFriendlyError, SeverityLevel.ERROR));
        }

        public void ReportError(ErrorContext errorContext)
        {
            Console.WriteLine($"Error at line {errorContext.Line}, column {errorContext.Start}-{errorContext.End}: {errorContext.Message}");
        }
    }
}
using OCLCMacroLanguage.Frontend.Parser;
using OCLCMacroLanguage.Frontend.SemanticAnalyzer.ASTBuilder;
using OCLCMacroLanguage.Frontend.SemanticAnalyzer;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MacroRunner.Frontend.SemanticAnalyzer
{
    public class TypeResolver : OMLParserBaseVisitor<object>
    {
        private readonly ISymbolTableScopeResolver symbolTable;

        public TypeResolver(ISymbolTableScopeResolver symbolTable)
        {
            this.symbolTable = symbolTable ?? throw new ArgumentNullException(nameof(symbolTable));
        }       
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace MacroRunner.Frontend.SemanticAnalyzer
{
    public class ErrorPostProcessor
    {
        public string TransformError(string antlrError)
        {
            string lineNumber = ExtractLineNumber(antlrError);
            string columnNumber = ExtractColumnNumber(antlrError);
            string errorMessage = ExtractErrorMessage(antlrError);

            string userFriendlyError = $"Error at line {lineNumber}, column {columnNumber}: {errorMessage}";

            return userFriendlyError;
        }

        private string ExtractLineNumber(string antlrError)
        {
            Match match = Regex.Match(antlrError, @"line (\d+)");
            return match.Success ? match.Groups[1].Value : "N/A";
        }

        private string ExtractColumnNumber(string antlrError)
        {
            Match match = Regex.Match(antlrError, @"column (\d+)");
            return match.Success ? match.Groups[1].Value : "N/A";
        }

        private string ExtractErrorMessage(string antlrError)
        {
            Match match = Regex.Match(antlrError, @"message: (.+)");
            return match.Success ? match.Groups[1].Value : "Unknown error";
        }
    }
}
using OCLCMacroLanguage.Frontend.SemanticAnalyzer.ASTBuilder;
using System.Collections.Generic;

namespace OCLCMacroLanguage.Frontend.SemanticAnalyzer
{
    public interface IAstNode
    {
        AstNodeType Type { get; }
        IAstNode Parent { get; set; }
        IEnumerable<IAstNode> Children { get; }
        ITypeSpec TypeSpec { get; set; }
        AstNodeProperties Properties { get; set; }

        void AddChild(IAstNode child);
    }
}
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace OCLCMacroLanguage.Frontend.SemanticAnalyzer
{
    public interface IAst
    {
        IAstNode Root { get; }
    }
}



